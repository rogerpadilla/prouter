{"version":3,"sources":["easy-router.js"],"names":[],"mappings":"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","file":"easy-router.js","sourcesContent":["/**\r\n * Unobtrusive and ultra-lightweight router library 100% compatible with the Backbone.Router's style for declaring routes,\r\n * while providing the following advantages:\r\n * - Unobtrusive, it is designed from the beginning to be integrated with other libraries / frameworks (also vanilla).\r\n * - Great performance, only native functions are used.\r\n * - Small footprint, 5kb for minified version.\r\n * - No dependencies, no jQuery, no Underscore... zero dependencies.\r\n * - Supports both routes' styles, hash and the pushState of History API.\r\n * - Proper JSDoc used in the source code.\r\n * - Works with normal script include and as well in CommonJS style.\r\n *\r\n * ¿Want to create a modern hibrid-app or a website using something like React, Web Components, Handlebars, vanilla JS, etc.?\r\n * ¿Have an existing Backbone project and want to migrate to a more modern framework?\r\n * Good news, EasyRouter will integrates perfectly with all of those!\r\n */\r\n\r\n/**\r\n * EasyRouter provides methods for routing client-side pages, and connecting them to actions.\r\n *\r\n * During page load, after your application has finished creating all of its routers,\r\n * be sure to call start() on the router instance to let know him you have already\r\n * finished the routing setup.\r\n */\r\n\r\nconst root = typeof global === 'undefined' ? window : global;\r\nconst document = root.document;\r\n\r\n// Cached regular expressions for matching named param parts and splatted\r\n// parts of route strings.\r\nconst optionalParam = /\\((.*?)\\)/g;\r\nconst namedParam = /(\\(\\?)?:\\w+/g;\r\nconst splatParam = /\\*\\w+/g;\r\nconst escapeRegExp = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;\r\nconst trueHash = /#(.*)$/;\r\nconst isRoot = /[^\\/]$/;\r\n\r\n// Cached regex for stripping a leading hash/slash and trailing space.\r\nconst routeStripper = /^[#\\/]|\\s+$/g;\r\n// Cached regex for stripping leading and trailing slashes.\r\nconst rootStripper = /^\\/+|\\/+$/g;\r\n// Cached regex for removing a trailing slash.\r\nconst trailingSlash = /\\/$/;\r\n// Cached regex for stripping urls of hash.\r\nconst pathStripper = /#.*$/;\r\n\r\n\r\n/**\r\n * Handles cross-browser history management, based on either\r\n * [pushState](http://diveintohtml5.info/history.html) and real URLs, or\r\n * [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)\r\n * and URL fragments.\r\n * @constructor\r\n */\r\n\r\nclass History {\r\n\r\n    constructor() {\r\n        // Has the history handling already been started?\r\n        this.started = false;\r\n        this.checkUrl = this.checkUrl.bind(this);\r\n        this.handlers = [];\r\n        this.evtHandlers = {};\r\n    }\r\n\r\n    /**\r\n     * Are we at the app root?\r\n     * @returns {boolean} if we are in the root.\r\n     */\r\n    atRoot() {\r\n        return History.location.pathname.replace(isRoot, '$&/') === this.root;\r\n    }\r\n\r\n    /**\r\n     * Gets the true hash value. Cannot use location.hash directly due to bug\r\n     * in Firefox where location.hash will always be decoded.\r\n     * @returns {string} The hash.\r\n     */\r\n    static getHash() {\r\n        const match = History.location.href.match(trueHash);\r\n        return match ? match[1] : '';\r\n    }\r\n\r\n    /**\r\n     * Get the cross-browser normalized URL fragment, either from the URL,\r\n     * the hash, or the override.\r\n     * @param {string} fragment The url fragment\r\n     * @param {boolean} forcePushState flag to force the usage of pushSate\r\n     * @returns {string} The fragment.\r\n     */\r\n    getFragment(fragment, forcePushState) {\r\n        if (fragment === undefined) {\r\n            if (this._hasPushState || !this._wantsHashChange || forcePushState) {\r\n                fragment = decodeURI(History.location.pathname + History.location.search);\r\n                const rootUrl = this.root.replace(trailingSlash, '');\r\n                if (!fragment.indexOf(rootUrl)) {\r\n                    fragment = fragment.slice(rootUrl.length);\r\n                }\r\n            } else {\r\n                fragment = History.getHash();\r\n            }\r\n        }\r\n        return fragment.replace(routeStripper, '');\r\n    }\r\n\r\n    /**\r\n     * Start the route change handling, returning `true` if the current URL matches\r\n     * an existing route, and `false` otherwise.\r\n     * @param {Object} options Options\r\n     * @returns {boolean} true if the current fragment matched some handler, false otherwise.\r\n     */\r\n    start(options) {\r\n\r\n        if (History.started) {\r\n            throw new Error('EasyRouter.history has already been started');\r\n        }\r\n\r\n        History.started = true;\r\n\r\n        // Figure out the initial configuration. Is pushState desired ... is it available?\r\n        this.opts = options || {};\r\n        this.opts.root = options.root || '/';\r\n        this.root = this.opts.root;\r\n        this._wantsHashChange = this.opts.hashChange !== false;\r\n        this._wantsPushState = !!this.opts.pushState;\r\n        this._hasPushState = !!(this.opts.pushState && History.history && History.history.pushState);\r\n\r\n        // Determine if we need to change the base url, for a pushState link\r\n        // opened by a non-pushState browser.\r\n        this.fragment = this.getFragment();\r\n\r\n        // Normalize root to always include a leading and trailing slash.\r\n        this.root = ('/' + this.root + '/').replace(rootStripper, '/');\r\n\r\n        // Depending on whether we're using pushState or hashes, and whether\r\n        // 'onhashchange' is supported, determine how we check the URL state.\r\n        if (this._hasPushState) {\r\n            root.addEventListener('popstate', this.checkUrl);\r\n        } else if (this._wantsHashChange && ('onhashchange' in root)) {\r\n            root.addEventListener('hashchange', this.checkUrl);\r\n        }\r\n\r\n        // Transition from hashChange to pushState or vice versa if both are\r\n        // requested.\r\n        if (this._wantsHashChange && this._wantsPushState) {\r\n\r\n            // If we've started off with a route from a `pushState`-enabled\r\n            // browser, but we're currently in a browser that doesn't support it...\r\n            if (!this._hasPushState && !this.atRoot()) {\r\n                this.fragment = this.getFragment(null, true);\r\n                History.location.replace(this.root + '#' + this.fragment);\r\n                // Return immediately as browser will do redirect to new url\r\n                return true;\r\n                // Or if we've started out with a hash-based route, but we're currently\r\n                // in a browser where it could be `pushState`-based instead...\r\n            } else if (this._hasPushState && this.atRoot() && History.location.hash) {\r\n                this.fragment = History.getHash().replace(routeStripper, '');\r\n                History.history.replaceState({}, document.title, this.root + this.fragment);\r\n            }\r\n\r\n        }\r\n\r\n        if (!this.opts.silent) {\r\n            return this.loadUrl();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disable EasyRouter.history, perhaps temporarily. Not useful in a real app,\r\n     * but possibly useful for unit testing Routers.\r\n     */\r\n    stop() {\r\n        root.removeEventListener('popstate', this.checkUrl);\r\n        root.removeEventListener('hashchange', this.checkUrl);\r\n        History.started = false;\r\n    }\r\n\r\n    /**\r\n     * Add a route to be tested when the fragment changes. Routes added later\r\n     * may override previous routes.\r\n     * @param {string} routeExp The route.\r\n     * @param {Function} callback Method to be executed.\r\n     */\r\n    route(routeExp, callback) {\r\n        this.handlers.unshift({route: routeExp, callback: callback});\r\n    }\r\n\r\n    /**\r\n     * Checks the current URL to see if it has changed, and if it has,\r\n     * calls `loadUrl`.\r\n     * @returns {boolean} true if navigated, false otherwise.\r\n     */\r\n    checkUrl() {\r\n        const current = this.getFragment();\r\n        if (current === this.fragment) {\r\n            return false;\r\n        }\r\n        this.loadUrl();\r\n    }\r\n\r\n    /**\r\n     * Attempt to load the current URL fragment. If a route succeeds with a\r\n     * match, returns `true`. If no defined routes matches the fragment,\r\n     * returns `false`.\r\n     * @param {string} fragment E.g.: 'user/pepito'\r\n     * @returns {boolean} true if the fragment matched some handler, false otherwise.\r\n     */\r\n    loadUrl(fragment) {\r\n        this.fragment = this.getFragment(fragment);\r\n        const n = this.handlers.length;\r\n        let handler;\r\n        for (let i = 0; i < n; i++) {\r\n            handler = this.handlers[i];\r\n            if (handler.route.test(this.fragment)) {\r\n                handler.callback(this.fragment);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Save a fragment into the hash history, or replace the URL state if the\r\n     * 'replace' option is passed. You are responsible for properly URL-encoding\r\n     * the fragment in advance.\r\n     *\r\n     * The options object can contain `trigger: true` if you wish to have the\r\n     * route callback be fired (not usually desirable), or `replace: true`, if\r\n     * you wish to modify the current URL without adding an entry to the History.history.\r\n     * @param {string} fragment Fragment to navigate to\r\n     * @param {Object} options Options object\r\n     * @returns {boolean} true if the fragment matched some handler, false otherwise.\r\n     */\r\n    navigate(fragment, options) {\r\n\r\n        if (!History.started) {\r\n            return false;\r\n        }\r\n\r\n        if (!options || options === true) {\r\n            options = {trigger: !!options};\r\n        }\r\n\r\n        let fragmentAux = this.getFragment(fragment || '');\r\n\r\n        // Strip the hash for matching.\r\n        fragmentAux = fragmentAux.replace(pathStripper, '');\r\n\r\n        let url = this.root + fragmentAux;\r\n\r\n        if (this.fragment === fragmentAux) {\r\n            return false;\r\n        }\r\n\r\n        this.fragment = fragmentAux;\r\n\r\n        // Don't include a trailing slash on the root.\r\n        if (fragmentAux === '' && url !== '/') {\r\n            url = url.slice(0, -1);\r\n        }\r\n\r\n        // If pushState is available, we use it to set the fragment as a real URL.\r\n        if (this._hasPushState) {\r\n            history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);\r\n            // If hash changes haven't been explicitly disabled, update the hash\r\n            // fragment to store History.history.\r\n        } else if (this._wantsHashChange) {\r\n            History._updateHash(fragmentAux, options.replace);\r\n            // If you've told us that you explicitly don't want fallback hashchange-\r\n            // based history, then `navigate` becomes a page refresh.\r\n        } else {\r\n            return History.location.assign(url);\r\n        }\r\n        if (options.trigger) {\r\n            return this.loadUrl(fragmentAux);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Add event listener.\r\n     * @param {string} evt Name of the event.\r\n     * @param {Function} callback Method.\r\n     * @returns {EasyRouter} this\r\n     */\r\n    on(evt, callback) {\r\n        if (this.evtHandlers[evt] === undefined) {\r\n            this.evtHandlers[evt] = [];\r\n        }\r\n        this.evtHandlers[evt].push(callback);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove event listener.\r\n     * @param {string} evt Name of the event.\r\n     * @param {Function} callback Method.\r\n     * @returns {EasyRouter} this\r\n     */\r\n    off(evt, callback) {\r\n        if (this.evtHandlers[evt]) {\r\n            const callbacks = this.evtHandlers[evt];\r\n            const n = callbacks.length;\r\n            for (let i = 0; i < n; i++) {\r\n                if (callbacks[i] === callback) {\r\n                    callbacks.splice(i, 1);\r\n                    if (callbacks.length === 0) {\r\n                        delete this.evtHandlers[evt];\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Events triggering.\r\n     * @param {string} evt Name of the event being triggered.\r\n     * @returns {boolean} if the event was listened or not.\r\n     */\r\n    trigger(evt) {\r\n        const callbacks = this.evtHandlers[evt];\r\n        if (callbacks === undefined) {\r\n            return false;\r\n        }\r\n        const args = Array.prototype.slice.call(arguments, 1);\r\n        let i = 0;\r\n        const callbacksLength = callbacks.length;\r\n        const respArr = [];\r\n        let resp;\r\n        for (; i < callbacksLength; i++) {\r\n            resp = callbacks[i].apply(this, args);\r\n            respArr.push(resp);\r\n        }\r\n        for (; i < callbacksLength; i++) {\r\n            if (respArr[i] === false) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Update the hash location, either replacing the current entry, or adding\r\n     * a new one to the browser history.\r\n     * @param {string} fragment URL fragment\r\n     * @param {boolean} replace flag\r\n     * @private\r\n     */\r\n    static _updateHash(fragment, replace) {\r\n        if (replace) {\r\n            const href = History.location.href.replace(/(javascript:|#).*$/, '');\r\n            History.location.replace(href + '#' + fragment);\r\n        } else {\r\n            // Some browsers require that `hash` contains a leading #.\r\n            History.location.hash = '#' + fragment;\r\n        }\r\n    }\r\n}\r\n\r\n\r\nHistory.location = root.location;\r\nHistory.history = root.history;\r\n\r\n\r\nclass EasyRouter {\r\n\r\n    /**\r\n     * Constructor for the router.\r\n     * Routers map faux-URLs to actions, and fire events when routes are\r\n     * matched. Creating a new one sets its `routes` hash, if not set statically.\r\n     * @param {Object} options options.root is a string indicating the site's context, defaults to '/'.\r\n     * @constructor\r\n     */\r\n    constructor(options = {}) {\r\n        this.evtHandlers = {};\r\n        this.opts = options;\r\n        this._bindRoutes();\r\n        if (this.opts.initialize) {\r\n            this.opts.initialize.apply(this, arguments);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Manually bind a single named route to a callback.\r\n     * The route argument may be a routing string or regular expression, each matching capture\r\n     * from the route or regular expression will be passed as an argument to the onCallback.\r\n     * @param {string|RegExp} routeExp The route\r\n     * @param {string|Function} name If string, alias for the entry; if Function, behaves like 'onCallback'.\r\n     * @param {Function} onCallback function to call when the new fragment match a route.\r\n     * @returns {EasyRouter} this\r\n     */\r\n    route(routeExp, name, onCallback) {\r\n\r\n        const routeAux = (Object.prototype.toString.call(routeExp) === '[object RegExp]') ? routeExp : EasyRouter._routeToRegExp(routeExp);\r\n\r\n        if (Object.prototype.toString.call(name) === '[object Function]') {\r\n            onCallback = name;\r\n            name = '';\r\n        }\r\n\r\n        if (!onCallback) {\r\n            onCallback = this.opts[name];\r\n            if (routeExp === 'implicit' && name === 'implicit') {\r\n                console.log('onCallback', name, onCallback);\r\n            }\r\n        }\r\n\r\n        const self = this;\r\n\r\n        EasyRouter.history.route(routeAux, function (fragment) {\r\n            const args = EasyRouter._extractParameters(routeAux, fragment);\r\n            self.execute(onCallback, args);\r\n            self.trigger.apply(self, ['route:' + name].concat(args));\r\n            self.trigger('route', name, args);\r\n            EasyRouter.history.trigger('route', self, name, args);\r\n        });\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Execute a route handler with the provided parameters.  This is an\r\n     * excellent place to do pre-route setup or post-route cleanup.\r\n     * @param {Function} callback The method to execute.\r\n     * @param {Array} args The parameters to pass to the method.\r\n     */\r\n    execute(callback, args) {\r\n        if (callback) {\r\n            callback.apply(this, args);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Simple proxy to `EasyRouter.history` to save a fragment into the history.\r\n     * @param {string} fragment Route to navigate to.\r\n     * @param {Object} options parameters\r\n     * @returns {EasyRouter} this\r\n     */\r\n    navigate(fragment, options) {\r\n        EasyRouter.history.navigate(fragment, options);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Bind all defined routes to `EasyRouter.history`. We have to reverse the\r\n     * order of the routes here to support behavior where the most general\r\n     * routes can be defined at the bottom of the route map.\r\n     * @private\r\n     */\r\n    _bindRoutes() {\r\n        if (!this.opts.routes) {\r\n            return;\r\n        }\r\n        const routes = Object.keys(this.opts.routes);\r\n        const routesN = routes.length - 1;\r\n        for (let i = routesN, route; i >= 0; i--) {\r\n            route = routes[i];\r\n            this.route(route, this.opts.routes[route]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert a route string into a regular expression, suitable for matching\r\n     * against the current location fragment.\r\n     * @param {string} route The route\r\n     * @returns {RegExp} the obtained regex\r\n     * @private\r\n     */\r\n    static _routeToRegExp(route) {\r\n        route = route.replace(escapeRegExp, '\\\\$&')\r\n            .replace(optionalParam, '(?:$1)?')\r\n            .replace(namedParam, function (match, optional) {\r\n                return optional ? match : '([^/?]+)';\r\n            })\r\n            .replace(splatParam, '([^?]*?)');\r\n        return new RegExp('^' + route + '(?:\\\\?([\\\\s\\\\S]*))?$');\r\n    }\r\n\r\n    /**\r\n     * Given a route, and a URL fragment that it matches, return the array of\r\n     * extracted decoded parameters. Empty or unmatched parameters will be\r\n     * treated as `null` to normalize cross-browser behavior.\r\n     * @param {RegExp} route The alias\r\n     * @param {string} fragment The url part\r\n     * @returns {Array} the extracted parameters\r\n     * @private\r\n     */\r\n    static _extractParameters(route, fragment) {\r\n        const params = route.exec(fragment).slice(1);\r\n        return params.map(function (param, i) {\r\n            // Don't decode the search params.\r\n            if (i === params.length - 1) {\r\n                return param || null;\r\n            }\r\n            return param ? decodeURIComponent(param) : null;\r\n        });\r\n    }\r\n\r\n}\r\n\r\n\r\nEasyRouter.History = History;\r\n\r\n/**\r\n * Copy event bus listeners.\r\n */\r\nEasyRouter.prototype.trigger = History.prototype.trigger;\r\nEasyRouter.prototype.on = History.prototype.on;\r\nEasyRouter.prototype.off = History.prototype.off;\r\n\r\n/**\r\n * Create the default EasyRouter.History.\r\n * @type {History}\r\n */\r\nEasyRouter.history = new EasyRouter.History();\r\n\r\n\r\nexport {EasyRouter as EasyRouter};\r\n"],"sourceRoot":"/source/"}